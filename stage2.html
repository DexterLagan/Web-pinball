<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stage2 – walls + pegs</title>
<style>
  html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}
  #ui{position:fixed;left:12px;bottom:12px;color:#cfd8dc;font:12px system-ui;z-index:3}
  #banner{position:fixed;top:0;left:0;right:0;background:#90caf9;color:#0b0d10;font:700 14px system-ui;padding:6px;text-align:center;z-index:3}
  #err{position:fixed;top:40px;left:0;right:0;background:#300;color:#fff;font:12px/1.4 system-ui;padding:6px;z-index:4;display:none;max-height:35vh;overflow:auto}
</style>
</head>
<body>
<div id="banner">STAGE 2 — table + ball + walls + pegs</div>
<div id="err"></div>
<div id="ui">S: pull plunger, release to launch · R: reset</div>
<script type="module">
if (location.search.includes('debug')) { const s=document.createElement('script'); s.src="https://cdn.jsdelivr.net/npm/eruda@3"; s.onload=()=>eruda.init(); document.body.appendChild(s); }
const errBox=document.getElementById('err'); const showErr=m=>{errBox.style.display='block'; errBox.textContent+=(m+"\n");};
addEventListener('error',e=>showErr('Error: '+e.message)); addEventListener('unhandledrejection',e=>showErr('Promise: '+(e.reason?.message||e.reason)));

import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js?v=s2b";
import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js?v=s2b";
import CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js?v=s2b";

const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b0d10);
const camera=new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0,10,20); camera.lookAt(0,0,0);
const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(innerWidth,innerHeight); 
document.body.appendChild(renderer.domElement);

// Camera controls (to inspect the scene)
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 0, 0);
controls.update();

// Always-visible sanity cube (if you see this, rendering works)
const sanityCube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshBasicMaterial({ color: 0xff5555 })
);
sanityCube.position.set(0, 1, 0);
scene.add(sanityCube);

// Make the background a touch lighter for contrast (temporary)
scene.background = new THREE.Color(0x17202a);

scene.add(new THREE.AxesHelper(3));

const world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)}); world.broadphase=new CANNON.SAPBroadphase(world); world.allowSleep=true;
const tiltRad=THREE.MathUtils.degToRad(6); world.gravity.set(Math.sin(tiltRad)*9.82, -Math.cos(tiltRad)*9.82, 0);

const matBall=new CANNON.Material('ball'); const matTable=new CANNON.Material('table'); const matPegs=new CANNON.Material('pegs');
world.addContactMaterial(new CANNON.ContactMaterial(matBall, matTable, {friction:0.2, restitution:0.2}));
world.addContactMaterial(new CANNON.ContactMaterial(matBall, matPegs,  {friction:0.0, restitution:0.85}));

const tableW=12, tableH=20, wallH=2, wallT=0.3;
const table=new THREE.Mesh(new THREE.PlaneGeometry(tableW,tableH), new THREE.MeshBasicMaterial({color:0x3a4a6a}));
table.rotation.x=-Math.PI/2; scene.add(table);
const ground=new CANNON.Body({mass:0, material:matTable, shape:new CANNON.Plane()});
ground.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(ground);

// walls
const wallMatVis=new THREE.MeshBasicMaterial({color:0x6c809c});
(function(){
  const top=new THREE.Mesh(new THREE.BoxGeometry(tableW,wallH,wallT), wallMatVis); top.position.set(0,wallH/2, tableH/2-wallT/2);
  const bot=new THREE.Mesh(new THREE.BoxGeometry(tableW,wallH,wallT), wallMatVis); bot.position.set(0,wallH/2,-tableH/2+wallT/2);
  scene.add(top,bot);
  const bTop=new CANNON.Body({mass:0, material:matTable}); bTop.addShape(new CANNON.Box(new CANNON.Vec3(tableW/2,wallH/2,wallT/2))); bTop.position.set(top.position.x,top.position.y,top.position.z); world.addBody(bTop);
  const bBot=new CANNON.Body({mass:0, material:matTable}); bBot.addShape(new CANNON.Box(new CANNON.Vec3(tableW/2,wallH/2,wallT/2))); bBot.position.set(bot.position.x,bot.position.y,bot.position.z); world.addBody(bBot);
  const len=tableH, t=wallT, h=wallH;
  const l=new THREE.Mesh(new THREE.BoxGeometry(t,h,len), wallMatVis); l.position.set(-tableW/2+t/2,h/2,0);
  const r=new THREE.Mesh(new THREE.BoxGeometry(t,h,len), wallMatVis); r.position.set( tableW/2 -t/2,h/2,0);
  scene.add(l,r);
  const bL=new CANNON.Body({mass:0, material:matTable}); bL.addShape(new CANNON.Box(new CANNON.Vec3(t/2,h/2,len/2))); bL.position.set(l.position.x,l.position.y,l.position.z); world.addBody(bL);
  const bR=new CANNON.Body({mass:0, material:matTable}); bR.addShape(new CANNON.Box(new CANNON.Vec3(t/2,h/2,len/2))); bR.position.set(r.position.x,r.position.y,r.position.z); world.addBody(bR);
})();

// pegs
const pegR=0.25, pegH=0.2; const pegGeom=new THREE.CylinderGeometry(pegR,pegR,pegH,12);
function addPeg(x,z){
  const vis=new THREE.Mesh(pegGeom, new THREE.MeshBasicMaterial({color:0xffc107})); vis.position.set(x,pegH/2,z); scene.add(vis);
  const shape=new CANNON.Cylinder(pegR,pegR,pegH,12);
  const quat=new CANNON.Quaternion(); quat.setFromEuler(Math.PI/2,0,0); // rotate axis to Y
  const body=new CANNON.Body({mass:0, material:matPegs}); body.addShape(shape, new CANNON.Vec3(0,0,0), quat); body.position.set(x,pegH/2,z); world.addBody(body);
}
for(let row=0; row<5; row++){
  const z=4.5-row*1.8; const cols=5+(row%2?1:0); const span=8;
  for(let i=0;i<cols;i++){ const x=-span/2+(i+0.5)*(span/cols)+(row%2?(span/(cols*2)):0); addPeg(x,z); }
}

// ball + plunger
const ballR=0.35;
const ballMesh=new THREE.Mesh(new THREE.SphereGeometry(ballR,24,16), new THREE.MeshBasicMaterial({color:0xffffff})); scene.add(ballMesh);
const ballBody=new CANNON.Body({mass:0.16, material:matBall, linearDamping:0.01, angularDamping:0.01}); ballBody.addShape(new CANNON.Sphere(ballR)); world.addBody(ballBody);
function resetBall(){ ballBody.position.set(4.2,2.0,-7.5); ballBody.velocity.set(0,0,0); ballBody.angularVelocity.set(0,0,0); } resetBall();

let pulling=false, plungerPower=0;
addEventListener('keydown', e=>{ if(e.code==='KeyS') pulling=true; if(e.code==='KeyR') resetBall(); });
addEventListener('keyup', e=>{
  if(e.code==='KeyS'){ pulling=false;
    ballBody.applyImpulse(new CANNON.Vec3(-Math.sin(tiltRad)*plungerPower*0.6, Math.cos(tiltRad)*plungerPower*0.6, plungerPower), ballBody.position);
    plungerPower=0;
  }
});

let last=performance.now(); const fixed=1/120;
function loop(t){
  const dt=Math.min((t-last)/1000,0.033); last=t;

  // Spin the sanity cube so you always see frame updates
  sanityCube.rotation.y = t * 0.0015;
  sanityCube.rotation.x = t * 0.0010;

  if(pulling) plungerPower=Math.min(plungerPower+50*dt, 40);
  world.step(fixed, dt, 8);
  ballMesh.position.copy(ballBody.position);
  ballMesh.quaternion.copy(ballBody.quaternion);

  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); });
</script>
<script>
  if (location.search.includes('debug')) {
    const s = document.createElement('script');
    s.src = "https://cdn.jsdelivr.net/npm/eruda";
    s.onload = () => { eruda.init(); };
    document.body.appendChild(s);
  }
</script>
</body>
</html>