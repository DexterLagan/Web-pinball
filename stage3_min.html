<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Stage 3 MIN — cube sanity (local ESM)</title>
<style>
  html,body{margin:0;height:100dvh;width:100vw;background:#000;overflow:hidden}
  #log{position:fixed;top:0;left:0;right:0;background:#111;color:#9ee;font:12px/1.5 system-ui;padding:8px;z-index:10;white-space:pre-wrap}
</style>
</head>
<body>
<div id="log">Booting…</div>
<script type="module">
const BUILD = "b8";                     // ← bump this when you edit
const logEl = document.getElementById('log');
const log = m => { logEl.textContent += "\n" + m; };
log("BUILD: " + BUILD);

let THREE;
try {
  THREE = await import('./vendor/three.min.js');   // your local ESM
  log('THREE r'+THREE.REVISION+' loaded');
} catch(e) { log('❌ import failed: '+e.message); throw e; }

// Scene (no background so clearColor shows)
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
camera.position.set(0, 1.5, 3); camera.lookAt(0, 1, 0);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, preserveDrawingBuffer:true });
document.body.appendChild(renderer.domElement);

// Canvas below the log so you can read messages
const c = renderer.domElement;
c.style.position = 'fixed';
c.style.left = '0'; c.style.top = '0';
c.style.zIndex = '1';                  // log is zIndex 10, so it stays on top
c.style.border = '4px solid lime';
c.style.background = '#ff00ff';        // canvas element’s CSS background
renderer.setClearColor(0xff00ff, 1);   // GL clear color (magenta)

// iPad-safe sizing in CSS px; lock DPR to 1 (no overscale)
function sizeNow(src){
  const vw = Math.round(document.documentElement.clientWidth  || innerWidth  || 1);
  const vh = Math.round(document.documentElement.clientHeight || innerHeight || 1);
  renderer.setPixelRatio(1);
  c.style.width  = vw + 'px';
  c.style.height = vh + 'px';
  renderer.setSize(vw, vh, true);
  camera.aspect = vw / Math.max(1, vh);
  camera.updateProjectionMatrix();
  const r = c.getBoundingClientRect();
  log(`↔️ ${src}: css=${vw}x${vh} | rect=${Math.round(r.width)}x${Math.round(r.height)} @ (${Math.round(r.left)},${Math.round(r.top)})`);
}
sizeNow('boot'); addEventListener('resize', ()=>sizeNow('resize'));

// Big red cube (cannot miss)
const cube = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,1),
  new THREE.MeshBasicMaterial({ color: 0xff5555 })
);
cube.position.set(0,1,0);
scene.add(cube);
// Reference grid
scene.add(new THREE.GridHelper(10,10,0x444444,0x444444));

let frames=0;
function loop(t){
  frames++;
  if (frames % 30 === 0) log(`frame ${frames}`);
  cube.rotation.y = t*0.0015; cube.rotation.x = t*0.001;
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>