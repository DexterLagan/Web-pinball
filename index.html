<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pinball Stage 1</title>
<style>html,body{margin:0;height:100%;background:#0b0d10;overflow:hidden}#ui{position:fixed;left:12px;bottom:12px;color:#cfd8dc;font:12px system-ui}</style>
</head>
<body>
<div id="ui">S: pull plunger, release to launch · R: reset</div>
<script type="module">
import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js?v=4";
import CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js?v=4";

// --- three ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0d10);
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 10, 20);
camera.lookAt(0,0,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// helpers (leave visible for sanity)
scene.add(new THREE.AxesHelper(3));

// --- cannon ---
const world = new CANNON.World({ gravity: new CANNON.Vec3(0,-9.82,0) });
world.broadphase = new CANNON.SAPBroadphase(world);
world.allowSleep = true;

// tilt the “world gravity” like a pinball table
const tiltRad = THREE.MathUtils.degToRad(6);
world.gravity.set(Math.sin(tiltRad)*9.82, -Math.cos(tiltRad)*9.82, 0);

// contact materials
const matBall  = new CANNON.Material('ball');
const matTable = new CANNON.Material('table');
world.addContactMaterial(new CANNON.ContactMaterial(matBall, matTable, { friction:0.2, restitution:0.2 }));

// table (visual plane + infinite physics plane)
const tableW=12, tableH=20;
const table = new THREE.Mesh(new THREE.PlaneGeometry(tableW, tableH), new THREE.MeshBasicMaterial({color:0x3a4a6a}));
table.rotation.x = -Math.PI/2;
scene.add(table);

const ground = new CANNON.Body({ mass:0, material:matTable, shape:new CANNON.Plane() });
ground.quaternion.setFromEuler(-Math.PI/2, 0, 0);
world.addBody(ground);

// ball
const ballR = 0.35;
const ballMesh = new THREE.Mesh(new THREE.SphereGeometry(ballR, 24, 16), new THREE.MeshBasicMaterial({color:0xffffff}));
scene.add(ballMesh);
const ballBody = new CANNON.Body({ mass:0.16, material:matBall, linearDamping:0.01, angularDamping:0.01 });
ballBody.addShape(new CANNON.Sphere(ballR));
world.addBody(ballBody);

function resetBall(){
  ballBody.position.set(4.2, 2.0, -7.5);
  ballBody.velocity.set(0,0,0);
  ballBody.angularVelocity.set(0,0,0);
}
resetBall();

// simple launcher (just an impulse when releasing S)
let pulling=false, plungerPower=0;
addEventListener('keydown', e=>{
  if(e.code==='KeyS') pulling=true;
  if(e.code==='KeyR') resetBall();
});
addEventListener('keyup', e=>{
  if(e.code==='KeyS'){
    pulling=false;
    ballBody.applyImpulse(
      new CANNON.Vec3(-Math.sin(tiltRad)*plungerPower*0.6, Math.cos(tiltRad)*plungerPower*0.6, plungerPower),
      ballBody.position
    );
    plungerPower=0;
  }
});

// loop
let last=performance.now(); const fixed=1/120;
function loop(t){
  const dt=Math.min((t-last)/1000, 0.033); last=t;
  if(pulling) plungerPower=Math.min(plungerPower+50*dt, 40);
  world.step(fixed, dt, 8);

  // sync mesh
  ballMesh.position.copy(ballBody.position);
  ballMesh.quaternion.copy(ballBody.quaternion);

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// resize
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>