<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Pinball Prototype</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0d10; overflow:hidden; }
    #overlay { position:fixed; left:12px; bottom:12px; color:#cfd8dc; font:12px/1.4 system-ui, sans-serif; opacity:.9; z-index:2 }
    .touch { position:fixed; bottom:0; width:50%; height:33%; opacity:0; } /* set to .2 to visualize */
    #leftTouch { left:0; } #rightTouch { right:0; }
  </style>
</head>
<body>
  <div id="overlay">
    ⇧ Left / ⇧ Right: flippers &nbsp; | &nbsp; S: pull plunger (hold) & release &nbsp; | &nbsp; Space: nudge<br/>
    Collisions: <span id="score">0</span>
  </div>
  <div id="leftTouch" class="touch"></div>
  <div id="rightTouch" class="touch"></div>

  <script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";
  // ⚠️ Use unpkg ESM build of cannon-es (skypack often fails in Codespaces)
  import CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

  // ----- Scene, Camera, Renderer -----
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0d10);

  const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0, 10, 20);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enabled = true; // enable for debugging; set false later if you want
  controls.target.set(0, 0, 0);
  controls.update();

  // Debug helper so you immediately see something if rendering is OK
  scene.add(new THREE.AxesHelper(3)); // red=X, green=Y, blue=Z

  // Lighting
  const hemi = new THREE.HemisphereLight(0xffffff, 0x101010, 0.7); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,7); dir.castShadow = true; scene.add(dir);

  // ----- Physics world -----
  const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
  world.broadphase = new CANNON.SAPBroadphase(world);
  world.allowSleep = true;

  // Table tilt via gravity vector
  const tableTiltDeg = 6;
  const tiltRad = THREE.MathUtils.degToRad(tableTiltDeg);
  world.gravity.set( Math.sin(tiltRad) * 9.82, -Math.cos(tiltRad) * 9.82, 0 );

  // Materials
  const matBall = new CANNON.Material('ball');
  const matTable = new CANNON.Material('table');
  const matPegs = new CANNON.Material('pegs');

  world.addContactMaterial(new CANNON.ContactMaterial(matBall, matTable, { friction: 0.2, restitution: 0.2 }));
  world.addContactMaterial(new CANNON.ContactMaterial(matBall, matPegs,  { friction: 0.0, restitution: 0.85 }));

  // ----- Helpers to sync Three <-> Cannon -----
  const bodies = []; // { mesh, body }
  function bind(mesh, body){ mesh.castShadow = mesh.receiveShadow = true; scene.add(mesh); world.addBody(body); bodies.push({mesh, body}); }

  // ----- Table -----
  const tableW = 12, tableH = 20, wallH = 2, wallT = 0.3;
  const tableGeo = new THREE.PlaneGeometry(tableW, tableH);
  const tableMat = new THREE.MeshStandardMaterial({ color: 0x223344, metalness: 0.0, roughness: 1.0 });
  const table = new THREE.Mesh(tableGeo, tableMat);
  table.rotation.x = -Math.PI/2;
  table.position.y = 0;
  table.receiveShadow = true;
  scene.add(table);

  // Static physics plane (infinite)
  const ground = new CANNON.Body({ mass: 0, material: matTable, shape: new CANNON.Plane() });
  ground.quaternion.setFromEuler(-Math.PI/2, 0, 0);
  world.addBody(ground);

  // Walls
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 1 });
  function wall(z, rotY=0){
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(tableW, wallH, wallT), wallMat);
    mesh.position.set(0, wallH/2, z);
    mesh.rotation.y = rotY;
    scene.add(mesh);

    const half = (rotY !== 0) ? new CANNON.Vec3(wallT/2, wallH/2, tableH/2) : new CANNON.Vec3(tableW/2, wallH/2, wallT/2);
    const body = new CANNON.Body({ mass: 0, material: matTable });
    body.addShape(new CANNON.Box(half));
    body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
    body.quaternion.setFromEuler(0, rotY, 0);
    world.addBody(body);
  }
  wall( tableH/2 - wallT/2);   // top
  wall(-tableH/2 + wallT/2);   // bottom

  // side walls
  (function sideWalls(){
    const len = tableH; const height = wallH; const thickness = wallT;
    const geo = new THREE.BoxGeometry(thickness, height, len);
    const left = new THREE.Mesh(geo, wallMat); left.position.set(-tableW/2 + thickness/2, height/2, 0);
    const right= new THREE.Mesh(geo, wallMat); right.position.set( tableW/2 - thickness/2, height/2, 0);
    scene.add(left,right);
    const leftBody = new CANNON.Body({ mass:0, material: matTable });
    leftBody.addShape(new CANNON.Box(new CANNON.Vec3(thickness/2,height/2,len/2)));
    leftBody.position.set(left.position.x, left.position.y, left.position.z);
    world.addBody(leftBody);
    const rightBody = new CANNON.Body({ mass:0, material: matTable });
    rightBody.addShape(new CANNON.Box(new CANNON.Vec3(thickness/2,height/2,len/2)));
    rightBody.position.set(right.position.x, right.position.y, right.position.z);
    world.addBody(rightBody);
  })();

  // ----- Pegs (nails) -----
  const pegMat = new THREE.MeshStandardMaterial({ color: 0xffc107, roughness: 0.4, metalness: 0.2 });
  const pegR = 0.25, pegH = 0.2;
  const pegGeom = new THREE.CylinderGeometry(pegR, pegR, pegH, 12);
  function addPeg(x,z){
    const mesh = new THREE.Mesh(pegGeom, pegMat);
    mesh.position.set(x, pegH/2, z);
    scene.add(mesh);

    // Cannon cylinder is along X by default; rotate so Y is height
    const shape = new CANNON.Cylinder(pegR, pegR, pegH, 12);
    const quat = new CANNON.Quaternion();
    quat.setFromEuler(Math.PI/2, 0, 0); // align axis to Y
    const body = new CANNON.Body({ mass:0, material: matPegs });
    body.addShape(shape, new CANNON.Vec3(0,0,0), quat);
    body.position.set(x, pegH/2, z);
    world.addBody(body);
  }
  for(let row=0; row<7; row++){
    const z = 6 - row*1.8;
    const cols = 5 + (row%2===0?0:1);
    for(let i=0;i<cols;i++){
      const span = 8;
      const x = -span/2 + (i+0.5)*(span/cols) + (row%2? (span/(cols*2)) : 0);
      addPeg(x, z);
    }
  }

  // ----- Ball -----
  const ballR = 0.35;
  const ballGeo = new THREE.SphereGeometry(ballR, 24, 16);
  const ballMat3 = new THREE.MeshStandardMaterial({ color: 0xeceff1, metalness: 0.0, roughness: 0.3 });
  const ballMesh = new THREE.Mesh(ballGeo, ballMat3);
  const ballBody = new CANNON.Body({ mass: 0.16, material: matBall, linearDamping: 0.01, angularDamping: 0.01 });
  ballBody.addShape(new CANNON.Sphere(ballR));
  bind(ballMesh, ballBody);
  resetBall();

  function resetBall(){
    ballBody.position.set(4.2, 2.0, -7.5); // launcher lane
    ballBody.velocity.set(0,0,0);
    ballBody.angularVelocity.set(0,0,0);
  }

  // ----- Launcher (plunger) -----
  let plungerPower = 0;
  let pulling = false;
  const launcherWallMat = new THREE.MeshStandardMaterial({ color: 0x607d8b });
  (function launcherLane(){
    const geo = new THREE.BoxGeometry(0.3, 1.0, 6.0);
    const m1 = new THREE.Mesh(geo, launcherWallMat); m1.position.set(3.8, 0.5, -5.0);
    const m2 = new THREE.Mesh(geo, launcherWallMat); m2.position.set(4.6, 0.5, -5.0);
    scene.add(m1,m2);
    const b1 = new CANNON.Body({ mass:0, material: matTable });
    b1.addShape(new CANNON.Box(new CANNON.Vec3(0.15,0.5,3.0))); b1.position.set(3.8,0.5,-5.0); world.addBody(b1);
    const b2 = new CANNON.Body({ mass:0, material: matTable });
    b2.addShape(new CANNON.Box(new CANNON.Vec3(0.15,0.5,3.0))); b2.position.set(4.6,0.5,-5.0); world.addBody(b2);
  })();

  // ----- Flippers -----
  const flipLen = 2.2, flipRad = 0.25;
  const flipGeo = new THREE.CylinderGeometry(flipRad, flipRad, flipLen, 16);
  function createFlipper(side=1){
    const color = side>0 ? 0x8bc34a : 0x03a9f4;
    const mesh = new THREE.Mesh(flipGeo, new THREE.MeshStandardMaterial({ color }));
    mesh.rotation.z = Math.PI/2;
    mesh.position.set(side*2.2, 0.6, -8.7);

    const body = new CANNON.Body({ mass: 1, material: matTable, angularDamping:0.2 });
    body.addShape(new CANNON.Box(new CANNON.Vec3(flipLen/2, flipRad, flipRad)));
    body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);

    // Hinge
    const pivot = new CANNON.Vec3(body.position.x + (side>0 ? -flipLen/2 + 0.2 : flipLen/2 - 0.2), body.position.y, body.position.z);
    const hinge = new CANNON.HingeConstraint(body, undefined, {
      pivotA: body.pointToLocalFrame(pivot),
      axisA: new CANNON.Vec3(0,1,0),
      pivotB: pivot,
      axisB: new CANNON.Vec3(0,1,0),
      collideConnected:false
    });
    world.addConstraint(hinge);

    const rest = side>0 ? -0.2 : 0.2;
    const up   = side>0 ?  0.9 : -0.9;
    hinge.setLimits(rest, up, 0.5, 0.3);
    hinge.enableMotor();

    return { mesh, body, hinge, side };
  }
  const leftFlip  = createFlipper(-1);
  const rightFlip = createFlipper(+1);
  scene.add(leftFlip.mesh, rightFlip.mesh);
  world.addBody(leftFlip.body);
  world.addBody(rightFlip.body);

  function setFlipper(what, active){
    const speed = active ? (what.side>0 ? +18 : -18) : (what.side>0 ? -12 : +12);
    const maxForce = 120;
    what.hinge.setMotorSpeed(speed);
    what.hinge.motorMaxForce = maxForce;
  }

  // ----- Collision scoring -----
  const scoreEl = document.getElementById('score');
  let score = 0;
  ballBody.addEventListener('collide', (e)=>{
    if(e.body.material && e.body.material.name === 'pegs'){
      score += 10;
      scoreEl.textContent = score.toString();
    }
  });

  // ----- Input -----
  window.addEventListener('keydown', (e)=>{
    if(e.code === 'ShiftLeft')  setFlipper(leftFlip,  true);
    if(e.code === 'ShiftRight') setFlipper(rightFlip, true);

    if(e.code === 'KeyS'){ pulling = true; }  // launcher
    if(e.code === 'KeyR'){ score=0; scoreEl.textContent='0'; resetBall(); }

    if(e.code === 'Space'){ // nudge
      ballBody.applyImpulse(new CANNON.Vec3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2), ballBody.position);
    }
  });

  window.addEventListener('keyup', (e)=>{
    if(e.code === 'ShiftLeft')  setFlipper(leftFlip,  false);
    if(e.code === 'ShiftRight') setFlipper(rightFlip, false);

    if(e.code === 'KeyS'){
      pulling = false;
      ballBody.applyImpulse(
        new CANNON.Vec3(-Math.sin(tiltRad)*plungerPower*0.6, Math.cos(tiltRad)*plungerPower*0.6, plungerPower),
        ballBody.position
      );
      plungerPower = 0;
    }
  });

  // Touch
  function onTouch(e, down){
    const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    if(x < innerWidth*0.5) setFlipper(leftFlip, down); else setFlipper(rightFlip, down);
  }
  const lt = document.getElementById('leftTouch');
  const rt = document.getElementById('rightTouch');
  lt.addEventListener('pointerdown', e=>onTouch(e,true));
  lt.addEventListener('pointerup',   e=>onTouch(e,false));
  rt.addEventListener('pointerdown', e=>onTouch(e,true));
  rt.addEventListener('pointerup',   e=>onTouch(e,false));

  // ----- Animate -----
  let last = performance.now();
  const fixedTimeStep = 1/120;
  function loop(t){
    const dt = Math.min((t-last)/1000, 0.033);
    last = t;

    if(pulling) plungerPower = Math.min(plungerPower + 50*dt, 40);

    world.step(fixedTimeStep, dt, 8);

    for(const {mesh, body} of bodies){
      mesh.position.copy(body.position);
      mesh.quaternion.copy(body.quaternion);
    }
    leftFlip.mesh.position.copy(leftFlip.body.position);
    leftFlip.mesh.quaternion.copy(leftFlip.body.quaternion);
    rightFlip.mesh.position.copy(rightFlip.body.position);
    rightFlip.mesh.quaternion.copy(rightFlip.body.quaternion);

    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Resize
  addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // Helpful: surface errors (so a single failed import doesn’t silently “go black”)
  window.addEventListener('error', (e)=> console.error('Window error:', e.message));
  window.addEventListener('unhandledrejection', (e)=> console.error('Unhandled promise rejection:', e.reason));
  </script>
</body>
</html>