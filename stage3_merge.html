<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Stage 3 MERGE — phased bring-up</title>
<style>
  html,body{margin:0;height:100dvh;width:100vw;background:#000;overflow:hidden}
  #log{position:fixed;top:0;left:0;right:0;background:#111;color:#9ee;
       font:12px/1.5 system-ui;padding:6px;z-index:10;white-space:pre-wrap;
       max-height:28vh;overflow:auto}
</style>
</head>
<body>
<div id="log">Booting…</div>

<!-- Cannon UMD → global CANNON -->
<script src="./vendor/cannon.min.js"></script>

<script type="module">
const BUILD = "b15";
const params = new URLSearchParams(location.search);
const PHASE = Number(params.get('phase') || 1); // 1..4
const logEl = document.getElementById('log');
const log = m => { logEl.textContent += "\n" + m; };
log("BUILD: " + BUILD + "  |  PHASE: " + PHASE);

let THREE;
try {
  THREE = await import('./vendor/three.min.js');   // local ESM you vendored
  log('THREE r'+THREE.REVISION+' loaded');
} catch(e) { log('❌ THREE import failed: '+e.message); throw e; }

if (!window.CANNON) { log('❌ CANNON missing (check ./vendor/cannon.min.js)'); throw new Error('No CANNON'); }
const CANNON = window.CANNON;

// --- scene
const scene = new THREE.Scene(); // leave background null so clearColor shows
const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 200);
// start centered on the sanity cube
camera.position.set(0, 1.5, 3); camera.lookAt(0, 1, 0);

// start near the cube, but switch to a top-down-ish view for gameplay
// Gameplay view (player side)
if (PHASE >= 2) {
  camera.position.set(0, 16, -14);   // was +14
  camera.lookAt(0, 0, 0);
}

// --- renderer
const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, preserveDrawingBuffer:true });
document.body.appendChild(renderer.domElement);
const c = renderer.domElement;
c.style.position = 'fixed'; c.style.left='0'; c.style.top='0';
c.style.zIndex = '1';               // keep log on top (z=10)
c.style.border = '4px solid lime';
c.style.background = '#ff00ff';     // CSS background (visible even before GL draw)
renderer.setClearColor(0xff00ff, 1);// GL clear

// iPad-safe sizing (CSS px, DPR=1)
function sizeNow(src){
  const vw = Math.round(document.documentElement.clientWidth  || innerWidth  || 1);
  const vh = Math.round(document.documentElement.clientHeight || innerHeight || 1);
  renderer.setPixelRatio(1);
  c.style.width  = vw + 'px';
  c.style.height = vh + 'px';
  renderer.setSize(vw, vh, true);
  camera.aspect = vw / Math.max(1, vh);
  camera.updateProjectionMatrix();
  const r = c.getBoundingClientRect();
  log(`↔️ ${src}: css=${vw}x${vh} | rect=${Math.round(r.width)}x${Math.round(r.height)} @ (${Math.round(r.left)},${Math.round(r.top)})`);
}
sizeNow('boot'); addEventListener('resize', ()=>sizeNow('resize'));

// sanity cube + grid (always on so we SEE frames)
const cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({ color: 0xff5555 }));
cube.position.set(0,1,0); scene.add(cube);
scene.add(new THREE.GridHelper(10,10,0x444444,0x444444));

// ---- PHYSICS (phase>=2)
let world, tiltRad, matBall, matTable, matPegs, ballMesh, ballBody, leftFlip, rightFlip;

if (PHASE >= 2) {
  world = new CANNON.World();
  tiltRad = 6 * Math.PI / 180;

// Down-table = toward +Z (camera side)
const gy = -Math.cos(tiltRad) * 9.82;
const gz =  Math.sin(tiltRad) * 9.82;   // ← +, not −
world.gravity.set(0, gy, gz);
log(`gravity set to (0, ${gy.toFixed(3)}, ${gz.toFixed(3)})`);

// (optional) mild defaults
world.defaultContactMaterial.friction = 0.2;
world.defaultContactMaterial.restitution = 0.15;

  world.broadphase = new CANNON.SAPBroadphase(world);
  world.allowSleep = true;

  tiltRad = 6*Math.PI/180;
  world.gravity.set(Math.sin(tiltRad)*9.82, -Math.cos(tiltRad)*9.82, 0);

  matBall  = new CANNON.Material('ball');
  matTable = new CANNON.Material('table');
  matPegs  = new CANNON.Material('pegs');
  world.addContactMaterial(new CANNON.ContactMaterial(matBall,  matTable, { friction:0.2, restitution:0.2 }));
  world.addContactMaterial(new CANNON.ContactMaterial(matBall,  matPegs,  { friction:0.0, restitution:0.85 }));

  // table plane (visual + infinite ground)
  const table = new THREE.Mesh(new THREE.PlaneGeometry(12,20), new THREE.MeshBasicMaterial({ color: 0x3a4a6a }));
  table.rotation.x = -Math.PI/2; scene.add(table);

  const ground = new CANNON.Body({ mass:0, material:matTable });
  ground.addShape(new CANNON.Plane());
  ground.quaternion.setFromEuler(-Math.PI/2,0,0);
  world.addBody(ground);

  // ball
  const r=0.35;
  ballMesh = new THREE.Mesh(new THREE.SphereGeometry(r,24,16), new THREE.MeshBasicMaterial({ color: 0xffffff }));
  scene.add(ballMesh);
  ballBody = new CANNON.Body({ mass:0.16, material:matBall, linearDamping:0.01, angularDamping:0.01 });
  ballBody.addShape(new CANNON.Sphere(r)); world.addBody(ballBody);
  function reset(){ ballBody.position.set(4.2,2,-7.5); ballBody.velocity.set(0,0,0); ballBody.angularVelocity.set(0,0,0); }
  reset();

  // simple plunger + reset
  let pulling=false, power=0;
  addEventListener('keydown', e=>{ if(e.code==='KeyS') pulling=true; if(e.code==='KeyR') reset(); });
  addEventListener('keyup', e=>{
    if(e.code==='KeyS'){
      pulling=false;
      ballBody.applyImpulse(new CANNON.Vec3(-Math.sin(tiltRad)*power*0.6, Math.cos(tiltRad)*power*0.6, power), ballBody.position);
      power=0;
    }
  });

  // keep power increasing each frame while held
  ballBody._plungerState = { pulling:false, power:0 };
  addEventListener('keydown', e=>{ if(e.code==='KeyS') ballBody._plungerState.pulling=true; });
  addEventListener('keyup',   e=>{ if(e.code==='KeyS'){ ballBody._plungerState.pulling=false; } });

  // store in world so loop can access
  world._tick = (dt)=>{
    const st = ballBody._plungerState;
    if(st.pulling) st.power = Math.min(st.power + 50*dt, 40);
    else st.power = Math.max(st.power, 0);
  };
}

if (PHASE >= 3) {
  // walls
  const wallMatVis = new THREE.MeshBasicMaterial({ color: 0x6c809c });
  function addWallBox(size,pos){
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x,size.y,size.z), wallMatVis);
    mesh.position.set(pos.x,pos.y,pos.z); scene.add(mesh);
    const body = new CANNON.Body({ mass:0, material:matTable });
    body.addShape(new CANNON.Box(new CANNON.Vec3(size.x/2,size.y/2,size.z/2)));
    body.position.set(pos.x,pos.y,pos.z); world.addBody(body);
  }
  const tableW=12, tableH=20, wallH=2, wallT=0.3;
  addWallBox({x:tableW,y:wallH,z:wallT},{x:0,y:wallH/2,z: tableH/2 - wallT/2});
  addWallBox({x:tableW,y:wallH,z:wallT},{x:0,y:wallH/2,z:-tableH/2 + wallT/2});
  addWallBox({x:wallT,y:wallH,z:tableH},{x:-tableW/2 + wallT/2,y:wallH/2,z:0});
  addWallBox({x:wallT,y:wallH,z:tableH},{x: tableW/2 - wallT/2,y:wallH/2,z:0});

  // pegs
  const pegR=0.25, pegH=0.2;
  const pegGeom = new THREE.CylinderGeometry(pegR, pegR, pegH, 12);
  function addPeg(x,z){
    const m = new THREE.Mesh(pegGeom, new THREE.MeshBasicMaterial({ color: 0xffc107 }));
    m.position.set(x, pegH/2, z); scene.add(m);
    const b = new CANNON.Body({ mass:0, material:matPegs });
    b.addShape(new CANNON.Cylinder(pegR, pegR, pegH, 12)); // Y axis cylinder
    b.position.set(x, pegH/2, z); world.addBody(b);
  }
  for(let row=0; row<5; row++){
    const z = 4.5 - row*1.8, cols = 5 + (row%2?1:0), span=8;
    for(let i=0;i<cols;i++){
      const x = -span/2 + (i+0.5)*(span/cols) + (row%2? (span/(cols*2)) : 0);
      addPeg(x, z);
    }
  }
}

if (PHASE >= 4) {
  const flipLen = 2.2, flipRad = 0.25;

  function createFlipper(side = 1) {
    // Visual
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(flipLen, flipRad*2, flipRad*2),
      new THREE.MeshBasicMaterial({ color: side>0 ? 0x8bc34a : 0x03a9f4 })
    );
    mesh.position.set(side*2.2, 0.6, -8.7);
    scene.add(mesh);

    // Body (more damping = less buzz)
    const body = new CANNON.Body({
      mass: 1, material: matTable,
      angularDamping: 0.55, linearDamping: 0.18
    });
    body.addShape(new CANNON.Box(new CANNON.Vec3(flipLen/2, flipRad, flipRad)));
    body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
    world.addBody(body);

    // Anchor at hinge pivot
    const pivotWorld = new CANNON.Vec3(
      body.position.x + (side>0 ? -flipLen/2 + 0.2 : flipLen/2 - 0.2),
      body.position.y, body.position.z
    );
    const anchor = new CANNON.Body({ mass: 0 });
    anchor.addShape(new CANNON.Sphere(0.01));
    anchor.position.copy(pivotWorld);
    world.addBody(anchor);

    const hinge = new CANNON.HingeConstraint(body, anchor, {
      pivotA: body.pointToLocalFrame(pivotWorld),
      axisA:  new CANNON.Vec3(0,1,0),
      pivotB: new CANNON.Vec3(0,0,0),
      axisB:  new CANNON.Vec3(0,1,0),
      collideConnected: false
    });
    world.addConstraint(hinge);
    hinge.enableMotor();

    // Clamp motor force (key for cannon.js)
    const MAX_FORCE = 100;  // try 80–140
    if (hinge.motorEquation) {
      hinge.motorEquation.maxForce =  MAX_FORCE;
      hinge.motorEquation.minForce = -MAX_FORCE;
    }

    // Control
    const ctrl = {
      rest: (side>0 ? -0.22 : 0.22),
      up:   (side>0 ?  0.85 : -0.85),
      target: (side>0 ? -0.22 : 0.22),
      kp: 10,   // softer stiffness
      kd: 12,   // more damping
      maxSpeed: 6,  // rad/s
      dead: 0.03,   // rad dead-band
      deadVel: 0.3  // rad/s dead-band
    };

    return { mesh, body, hinge, anchor, ctrl, side };
  }

  leftFlip  = createFlipper(-1);
  rightFlip = createFlipper(+1);
  log('Flippers: OK (PD + dead-band)');

  function setFlipper(f, on){ if(!f) return; f.ctrl.target = on ? f.ctrl.up : f.ctrl.rest; }

  addEventListener('keydown', e=>{
    if(e.code==='ShiftLeft')  setFlipper(leftFlip,  true);
    if(e.code==='ShiftRight') setFlipper(rightFlip, true);
    if(e.code==='Space' && ballBody){
      ballBody.applyImpulse(new CANNON.Vec3((Math.random()-0.5)*2, 0, (Math.random()-0.5)*2), ballBody.position);
    }
  });
  addEventListener('keyup', e=>{
    if(e.code==='ShiftLeft')  setFlipper(leftFlip,  false);
    if(e.code==='ShiftRight') setFlipper(rightFlip, false);
  });
}

// --- loop (always draws cube; physics added by phase)
let frames=0, last=performance.now(); const fixed=1/120;
function loop(t){
  const dt=Math.min((t-last)/1000,0.033); last=t;

  frames++; 
  // if (frames%30===0) log(`frame ${frames}`);
  cube.rotation.y = t*0.0015; cube.rotation.x = t*0.001;

  if (PHASE >= 2) {
    world._tick && world._tick(dt);
    world.step(fixed, dt, 8);
    ballMesh.position.copy(ballBody.position);
    ballMesh.quaternion.copy(ballBody.quaternion);
  }

  if (PHASE >= 4 && leftFlip && rightFlip) {
  function wrapPi(a){ a=(a+Math.PI)%(2*Math.PI); return a<0?a+2*Math.PI-Math.PI:a-Math.PI; }
  function driveFlipper(f){
    // world-space direction of local +X axis
    const ax = new CANNON.Vec3(1,0,0);
    f.body.quaternion.vmult(ax, ax);
    const angle = wrapPi(Math.atan2(ax.x, ax.z));   // yaw around Y
    const velY  = f.body.angularVelocity.y || 0;

    let err = wrapPi(f.ctrl.target - angle);

    // Dead-band: stop motor if close & slow
    if (Math.abs(err) < f.ctrl.dead && Math.abs(velY) < f.ctrl.deadVel) {
      f.hinge.setMotorSpeed(0);
      return;
    }

    let speed = f.ctrl.kp * err - f.ctrl.kd * velY;
    const m = f.ctrl.maxSpeed;
    if (speed >  m) speed =  m;
    if (speed < -m) speed = -m;

    f.hinge.setMotorSpeed(speed);
  }
  driveFlipper(leftFlip);
  driveFlipper(rightFlip);

  // sync visuals
  leftFlip.mesh.position.copy(leftFlip.body.position);
  leftFlip.mesh.quaternion.copy(leftFlip.body.quaternion);
  rightFlip.mesh.position.copy(rightFlip.body.position);
  rightFlip.mesh.quaternion.copy(rightFlip.body.quaternion);
}

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>